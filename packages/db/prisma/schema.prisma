// This is your Prisma schema file.
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator python {
  provider             = "prisma-client-py"
  recursive_type_depth = 5
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CORE MODELS (Auth + Trips)
// ============================================================================

model User {
  id                 String           @id @default(uuid())
  email              String           @unique
  name               String?
  image              String?
  avatarUrl          String?
  googleId           String?          @unique
  emailVerified      DateTime?
  subscriptionTier   SubscriptionTier @default(beta)
  systemRole         SystemRole       @default(user)
  featureFlags       Json?
  accessCohort       String?
  stripeCustomerId   String?          @unique
  stripeSubId        String?
  stripePriceId      String?
  onboardingComplete Boolean          @default(false)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  lastActiveAt       DateTime?

  sessions        Session[]
  accounts        Account[]
  tripMembers     TripMember[]
  backfillTrips   BackfillTrip[]
  backfillSignals BackfillSignal[]
  personaDeltas   PersonaDelta[]
  tripPhotos      TripPhoto[]

  userPreference         UserPreference?
  notificationPreference NotificationPreference?
  dataConsent            DataConsent?

  // V2 ML relations
  arbitrationEvents       ArbitrationEvent[]
  importJobs              ImportJob[]
  corpusIngestionRequests CorpusIngestionRequest[]

  // Group features
  messages      Message[]
  paidExpenses  Expense[]

  @@map("users")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
  createdAt    DateTime @default(now())

  @@map("sessions")
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Trip {
  id               String     @id @default(uuid())
  userId           String
  name             String?
  mode             TripMode
  status           TripStatus @default(draft)
  startDate        DateTime
  endDate          DateTime
  groupId          String?
  memberCount      Int?
  planningProgress Float?
  presetTemplate   String?
  personaSeed      Json?
  fairnessState    Json?
  affinityMatrix   Json?
  logisticsState   Json?
  packingList      Json?
  reflectionData   Json?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  activatedAt      DateTime?
  completedAt      DateTime?

  currency     String    @default("USD")

  legs         TripLeg[]
  members      TripMember[]
  slots        ItinerarySlot[]
  sharedTokens SharedTripToken[]
  inviteTokens InviteToken[]
  photos       TripPhoto[]
  messages     Message[]
  expenses     Expense[]

  @@map("trips")
}

model TripLeg {
  id     String @id @default(uuid())
  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  position    Int // 0-indexed ordering within the trip route
  city        String
  country     String
  timezone    String? // nullable for freeform cities without timezone lookup
  destination String // "Kyoto, Japan" display string

  startDate DateTime
  endDate   DateTime

  arrivalTime   String? // "morning", "afternoon", "evening"
  departureTime String?

  // Inter-leg transit (position 0 has null transit fields)
  transitMode        String?
  transitDurationMin Int?
  transitCostHint    String?
  transitConfirmed   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  slots ItinerarySlot[]

  @@unique([tripId, position])
  @@index([tripId])
  @@index([city])
  @@map("trip_legs")
}

model TripMember {
  id            String       @id @default(uuid())
  tripId        String
  trip          Trip         @relation(fields: [tripId], references: [id], onDelete: Cascade)
  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          TripRole
  status        MemberStatus @default(invited)
  personaSeed   Json?
  energyProfile Json?
  joinedAt      DateTime?
  createdAt     DateTime     @default(now())

  @@unique([tripId, userId])
  @@index([tripId, status])
  @@map("trip_members")
}

model Message {
  id        String         @id @default(uuid())
  tripId    String
  trip      Trip           @relation(fields: [tripId], references: [id], onDelete: Cascade)
  userId    String
  user      User           @relation(fields: [userId], references: [id])
  body      String         // plain text, max 2000 chars, HTML-stripped before storage
  slotRefId String?        // optional embedded slot reference
  slotRef   ItinerarySlot? @relation(fields: [slotRefId], references: [id], onDelete: SetNull)
  createdAt DateTime       @default(now())

  @@index([tripId, createdAt])
  @@map("messages")
}

model Expense {
  id          String   @id @default(uuid())
  tripId      String
  trip        Trip     @relation(fields: [tripId], references: [id], onDelete: Cascade)
  paidById    String
  paidBy      User     @relation(fields: [paidById], references: [id])
  description String   // max 200 chars
  amountCents Int      // stored in smallest currency unit
  splitWith   String[] // userIds included in split; empty = all joined members
  slotId      String?  // optional link to an itinerary slot
  createdAt   DateTime @default(now())

  @@index([tripId, createdAt])
  @@map("expenses")
}

model ItinerarySlot {
  id              String        @id @default(uuid())
  tripId          String
  trip            Trip          @relation(fields: [tripId], references: [id], onDelete: Cascade)
  tripLegId       String?
  tripLeg         TripLeg?      @relation(fields: [tripLegId], references: [id], onDelete: Cascade)
  activityNodeId  String?
  activityNode    ActivityNode? @relation(fields: [activityNodeId], references: [id])
  dayNumber       Int
  sortOrder       Int
  slotType        SlotType
  status          SlotStatus    @default(proposed)
  startTime       DateTime?
  endTime         DateTime?
  durationMinutes Int?
  isLocked        Boolean       @default(false)
  voteState       Json?
  isContested     Boolean       @default(false)
  swappedFromId   String?
  pivotEventId    String?
  wasSwapped      Boolean       @default(false)
  ownerTip        String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  assignedTo      String[]              @default([])

  completionSignal SlotCompletionSignal? // V2 ML: slot outcome classification

  photos   TripPhoto[]
  messages Message[]

  @@index([tripLegId])
  @@map("itinerary_slots")
}

// ============================================================================
// WORLD KNOWLEDGE (ActivityNodes + Vibe Tags)
// ============================================================================

model ActivityNode {
  id               String           @id @default(uuid())
  name             String
  slug             String           @unique
  canonicalName    String
  city             String
  country          String
  neighborhood     String?
  latitude         Float
  longitude        Float
  category         ActivityCategory
  subcategory      String?
  priceLevel       Int?
  hours            Json?
  address          String?
  phoneNumber      String?
  websiteUrl       String?
  foursquareId     String?          @unique
  googlePlaceId    String?          @unique
  primaryImageUrl  String?
  imageSource      String?
  imageValidated   Boolean          @default(false)
  sourceCount      Int              @default(0)
  convergenceScore Float?
  authorityScore   Float?
  descriptionShort String?
  descriptionLong  String?
  contentHash      String?
  lastScrapedAt    DateTime?
  lastValidatedAt  DateTime?
  status           NodeStatus       @default(pending)
  flagReason       String?
  resolvedToId     String?
  isCanonical      Boolean          @default(true)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // V2 ML: scoring + feedback loop columns
  tourist_score            Float?
  tourist_local_divergence Float?
  impression_count         Int       @default(0)
  acceptance_count         Int       @default(0)
  behavioral_quality_score Float     @default(0.5) // Laplace: (acceptance+1)/(impression+2)
  llm_served_count         Int       @default(0)
  ml_served_count          Int       @default(0)
  // Pre-launch behavioral scaffolding
  behavioralUpdatedAt      DateTime? // timestamp of last behavioral write-back
  cantMiss                 Boolean   @default(false) // ~0.1% of nodes. Score floor 0.72. Set during seeding.

  // Pipeline D: LLM Research Synthesis additive columns
  researchSynthesisId      String?
  pipelineDConfidence      Float?
  pipelineCConfidence      Float?
  crossRefAgreementScore   Float?
  sourceAmplificationFlag  Boolean   @default(false)
  signalConflictFlag       Boolean   @default(false)
  temporalNotes            String?   @map("pipelineDTemporalNotes")

  vibeTags       ActivityNodeVibeTag[]
  aliases        ActivityAlias[]
  qualitySignals QualitySignal[]
  slots          ItinerarySlot[]
  backfillVenues BackfillVenue[]

  @@map("activity_nodes")
}

model VibeTag {
  id        String   @id @default(uuid())
  slug      String   @unique
  name      String
  category  String
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  activityNodeVibeTags ActivityNodeVibeTag[]

  @@map("vibe_tags")
}

model ActivityNodeVibeTag {
  id             String       @id @default(uuid())
  activityNodeId String
  activityNode   ActivityNode @relation(fields: [activityNodeId], references: [id], onDelete: Cascade)
  vibeTagId      String
  vibeTag        VibeTag      @relation(fields: [vibeTagId], references: [id], onDelete: Cascade)
  score          Float
  source         String
  createdAt      DateTime     @default(now())

  @@unique([activityNodeId, vibeTagId, source])
  @@map("activity_node_vibe_tags")
}

model ActivityAlias {
  id             String       @id @default(uuid())
  activityNodeId String
  activityNode   ActivityNode @relation(fields: [activityNodeId], references: [id], onDelete: Cascade)
  alias          String
  source         String
  createdAt      DateTime     @default(now())

  @@index([alias])
  @@index([activityNodeId])
  @@map("activity_aliases")
}

model QualitySignal {
  id                  String       @id @default(uuid())
  activityNodeId      String
  activityNode        ActivityNode @relation(fields: [activityNodeId], references: [id], onDelete: Cascade)
  sourceName          String
  sourceUrl           String?
  sourceAuthority     Float
  signalType          String
  rawExcerpt          String?
  extractedAt         DateTime
  // Pre-launch: data seeding pipeline provenance
  extractionMetadata  Json?        // overrated_flag, price_signal, author_type, crowd_notes
  createdAt           DateTime     @default(now())

  @@index([activityNodeId, sourceName])
  @@map("quality_signals")
}

model CityVibeProfile {
  id         String   @id @default(uuid())
  city       String // canonical city name
  country    String
  vibeKey    String // maps to vibe archetype: "warm_slow", "dense_late", "remote_physical", "old_layered"
  score      Float // 0.0 - 1.0, how well this city matches the vibe
  nodeCount  Int // total approved ActivityNodes for this city (readiness gate)
  catCount   Int // distinct categories represented (readiness gate)
  imageUrl   String? // atmospheric Unsplash photo URL
  tagline    String? // one-line "why this city" (pre-generated, cached)
  computedAt DateTime @default(now())

  @@unique([city, vibeKey])
  @@index([vibeKey, score])
  @@index([city])
  @@map("city_vibe_profiles")
}

// ============================================================================
// SIGNALS (Behavioral + Intention + Raw Events)
// ============================================================================

model BehavioralSignal {
  id             String     @id @default(uuid())
  userId         String
  tripId         String?
  slotId         String?
  activityNodeId String?
  signalType     SignalType
  signalValue    Float
  tripPhase      TripPhase
  rawAction      String
  weatherContext String?
  modelVersion   String?
  promptVersion  String?
  // V2 ML: signal quality + provenance
  subflow        String? // context tag: which subflow generated this signal
  signal_weight  Float      @default(1.0) // confidence weight, SERVER-ONLY (never from client). CHECK [-1.0, 3.0] via migration SQL
  source         String     @default("user_behavioral") // origin: user_behavioral | synthetic_agent_v1 | backfill | chatgpt_import
  // Pre-launch behavioral scaffolding
  candidateSetId String?    // UUID linking to the RankingEvent that produced this signal
  candidateIds   String[]   @default([]) // full candidate pool shown to user
  metadata       Json?      // RECONCILE: column already exists in DB + SA model (signal_metadata attr)
  createdAt      DateTime   @default(now())

  @@index([userId, createdAt])
  @@index([userId, tripId, signalType, source]) // V2: compound index with source for quarantine queries
  @@index([activityNodeId, signalType])
  @@index([candidateSetId])
  @@map("behavioral_signals")
}

model IntentionSignal {
  id                 String   @id @default(uuid())
  behavioralSignalId String
  rawEventId         String?
  userId             String
  intentionType      String
  confidence         Float
  source             String
  userProvided       Boolean  @default(false)
  createdAt          DateTime @default(now())

  @@index([behavioralSignalId])
  @@index([userId, intentionType])
  @@map("intention_signals")
}

model RawEvent {
  id             String      @id @default(uuid())
  userId         String
  sessionId      String
  tripId         String?
  activityNodeId String?
  clientEventId  String?
  eventType      String
  intentClass    IntentClass
  surface        String?
  payload        Json
  platform       String?
  screenWidth    Int?
  networkType    String?
  // Pre-launch behavioral scaffolding
  trainingExtracted Boolean   @default(false)
  extractedAt       DateTime?
  createdAt      DateTime    @default(now())

  @@unique([userId, clientEventId])
  @@index([userId, eventType, createdAt])
  @@index([userId, activityNodeId])
  @@index([sessionId])
  @@index([createdAt])
  @@index([intentClass, eventType])
  @@index([trainingExtracted, createdAt])
  @@map("raw_events")
}

// ============================================================================
// ML + ADMIN
// ============================================================================

model ModelRegistry {
  id                String     @id @default(uuid())
  modelName         String
  modelVersion      String
  stage             ModelStage
  modelType         String
  description       String?
  artifactPath      String?
  artifactHash      String?
  configSnapshot    Json?
  metrics           Json?
  evaluatedAt       DateTime?
  trainingDataRange Json?
  parentVersionId   String?
  promotedAt        DateTime?
  promotedBy        String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@unique([modelName, modelVersion])
  @@index([modelName, stage])
  @@map("model_registry")
}

model ResearchJob {
  id                  String            @id @default(uuid())
  cityId              String
  status              ResearchJobStatus @default(QUEUED)
  triggeredBy         ResearchTrigger
  modelVersion        String
  passATokens         Int               @default(0)
  passBTokens         Int               @default(0)
  totalCostUsd        Float             @default(0)
  venuesResearched    Int               @default(0)
  venuesResolved      Int               @default(0)
  venuesUnresolved    Int               @default(0)
  validationWarnings  Json?
  errorMessage        String?
  createdAt           DateTime          @default(now())
  completedAt         DateTime?

  synthesis           CityResearchSynthesis?
  venueSignals        VenueResearchSignal[]
  crossRefResults     CrossReferenceResult[]

  @@index([cityId, createdAt])
  @@index([status])
  @@map("research_jobs")
}

model CityResearchSynthesis {
  id                       String      @id @default(uuid())
  researchJobId            String      @unique
  researchJob              ResearchJob @relation(fields: [researchJobId], references: [id], onDelete: Cascade)
  cityId                   String
  neighborhoodCharacter    Json
  temporalPatterns         Json
  peakAndDeclineFlags      Json
  sourceAmplificationFlags Json
  divergenceSignals        Json
  synthesisConfidence      Float
  modelVersion             String
  generatedAt              DateTime

  venueSignals VenueResearchSignal[]

  @@index([cityId])
  @@map("city_research_syntheses")
}

model VenueResearchSignal {
  id                           String                 @id @default(uuid())
  researchJobId                String
  researchJob                  ResearchJob            @relation(fields: [researchJobId], references: [id], onDelete: Cascade)
  cityResearchSynthesisId      String?
  cityResearchSynthesis        CityResearchSynthesis? @relation(fields: [cityResearchSynthesisId], references: [id])
  activityNodeId               String?
  venueNameRaw                 String
  resolutionMatchType          String?
  resolutionConfidence         Float?
  vibeTags                     String[]
  touristScore                 Float?
  temporalNotes                String?
  sourceAmplification          Boolean                @default(false)
  localVsTouristSignalConflict Boolean                @default(false)
  researchConfidence           Float?
  knowledgeSource              KnowledgeSource?
  notes                        String?
  createdAt                    DateTime               @default(now())

  unresolvedSignal UnresolvedResearchSignal?

  @@index([researchJobId])
  @@index([activityNodeId])
  @@map("venue_research_signals")
}

model UnresolvedResearchSignal {
  id                       String              @id @default(uuid())
  venueResearchSignalId    String              @unique
  venueResearchSignal      VenueResearchSignal @relation(fields: [venueResearchSignalId], references: [id], onDelete: Cascade)
  cityId                   String
  venueNameRaw             String
  resolutionAttempts       Int                 @default(0)
  lastAttemptAt            DateTime?
  resolvedAt               DateTime?
  resolvedToActivityNodeId String?

  @@index([cityId, resolvedAt])
  @@map("unresolved_research_signals")
}

model CrossReferenceResult {
  id                 String      @id @default(uuid())
  activityNodeId     String
  cityId             String
  researchJobId      String
  researchJob        ResearchJob @relation(fields: [researchJobId], references: [id], onDelete: Cascade)
  hasPipelineDSignal Boolean     @default(false)
  hasPipelineCSignal Boolean     @default(false)
  dOnly              Boolean     @default(false)
  cOnly              Boolean     @default(false)
  bothAgree          Boolean     @default(false)
  bothConflict       Boolean     @default(false)
  tagAgreementScore  Float?
  touristScoreDelta  Float?
  signalConflict     Boolean     @default(false)
  mergedVibeTags     String[]
  mergedTouristScore Float?
  mergedConfidence   Float?
  resolvedBy         String?
  resolvedAt         DateTime?
  resolutionAction   String?
  previousValues     Json?
  computedAt         DateTime    @default(now())

  @@unique([activityNodeId, researchJobId])
  @@index([cityId])
  @@index([signalConflict])
  @@map("cross_reference_results")
}

model PersonaDimension {
  id         String   @id @default(uuid())
  userId     String
  dimension  String
  value      String
  confidence Float    @default(1.0)
  source     String   @default("onboarding")
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  negativeTagAffinities Json?   // JSONB: {"hidden-gem": -0.3, "party-central": -0.8} — vibe tags the user rejects
  version               Int     @default(0) // incremented by nightly batch; TripPersonaCache checks this

  @@unique([userId, dimension])
  @@index([userId])
  @@index([dimension, value])
  @@map("persona_dimensions")
}

model RankingEvent {
  id                 String   @id @default(uuid())
  userId             String
  tripId             String
  sessionId          String?
  dayNumber          Int
  modelName          String
  modelVersion       String
  candidateIds       String[]
  rankedIds          String[]
  selectedIds        String[]
  surface            String
  shadowModelName    String?
  shadowModelVersion String?
  shadowRankedIds    String[]
  latencyMs          Int?
  // Pre-launch behavioral scaffolding
  acceptedId         String?
  rejectedIds        String[] @default([])
  viewedIds          String[] @default([])
  viewDurations      Json?    // { activityNodeId: milliseconds_viewed }
  weatherContext     Json?    // { condition, temp_celsius, precipitation_pct, wind_kph }
  personaSnapshot    Json?    // denormalized persona dimensions at ranking time
  candidateSetId     String?  @unique // UUID join key → BehavioralSignal.candidateSetId

  // Pipeline D: cross-reference training features
  hasDSignal              Boolean?
  hasCSignal              Boolean?
  dCAgreement             Float?
  signalConflictAtServe   Boolean?
  dKnowledgeSource        String?
  rankPipelineDConfidence Float?

  createdAt          DateTime @default(now())

  @@index([userId, createdAt])
  @@index([tripId, dayNumber])
  @@index([modelName, modelVersion])
  @@map("ranking_events")
}

model PivotEvent {
  id             String       @id @default(uuid())
  tripId         String
  slotId         String
  triggerType    PivotTrigger
  triggerPayload Json?
  originalNodeId String
  alternativeIds String[]
  selectedNodeId String?
  status         PivotStatus  @default(proposed)
  resolvedAt     DateTime?
  responseTimeMs Int?
  createdAt      DateTime     @default(now())

  @@index([tripId, createdAt])
  @@index([status])
  @@map("pivot_events")
}

// ============================================================================
// V2 ML: Arbitration + Import + Corpus + Write-Back
// ============================================================================

model ArbitrationEvent {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tripId          String
  mlTop3          String[] // top 3 activity node IDs from ML arm
  llmTop3         String[] // top 3 activity node IDs from LLM arm
  arbitrationRule String // which rule resolved: ml_wins, llm_wins, blend, etc.
  servedSource    String // final source: "ml" | "llm" | "blend"
  accepted        Boolean? // did user accept the served recommendation?
  agreementScore  Float? // overlap score between ML and LLM rankings
  contextSnapshot Json? // persona_vibes, ml_scores, llm_scores — no raw user text. CHECK pg_column_size < 65536 via migration SQL
  createdAt       DateTime @default(now())

  @@index([userId, createdAt])
  @@index([tripId])
  @@index([arbitrationRule])
  @@map("arbitration_events")
}

model ImportJob {
  id                  String          @id @default(uuid())
  userId              String
  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  status              ImportJobStatus @default(pending)
  parserVersion       String?
  conversationsFound  Int             @default(0)
  travelConversations Int             @default(0)
  signalsExtracted    Int             @default(0)
  errorMessage        String?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  signals ImportPreferenceSignal[]

  @@index([userId, status])
  @@map("import_jobs")
}

model ImportPreferenceSignal {
  id                  String    @id @default(uuid())
  importJobId         String
  importJob           ImportJob @relation(fields: [importJobId], references: [id], onDelete: Cascade)
  dimension           String // persona dimension key
  direction           String // positive | negative
  confidence          Float
  sourceText          String? // max 500 chars, PII-scrubbed, HTML-encoded
  piiScrubbed         Boolean   @default(false)
  sourceTextExpiresAt DateTime? // set to created_at + 90 days at creation
  trainingExcluded    Boolean   @default(false) // true if DataConsent.modelTraining is false
  createdAt           DateTime  @default(now())

  @@index([importJobId])
  @@index([dimension, direction])
  @@map("import_preference_signals")
}

model CorpusIngestionRequest {
  id           String                @id @default(uuid())
  userId       String
  user         User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  tripId       String?
  rawPlaceName String
  source       String // "off_plan_add" | "user_suggestion" | "chatgpt_import"
  status       CorpusIngestionStatus @default(pending)
  createdAt    DateTime              @default(now())

  @@index([userId])
  @@index([status])
  @@map("corpus_ingestion_requests")
}

model WriteBackRun {
  id           String   @id @default(uuid())
  runDate      DateTime // the date this write-back covers
  status       String // success | partial | failed
  rowsUpdated  Int      @default(0)
  durationMs   Int?
  errorMessage String?
  createdAt    DateTime @default(now())

  @@unique([runDate])
  @@map("write_back_runs")
}

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String
  action     String
  targetType String
  targetId   String
  before     Json?
  after      Json?
  ipAddress  String
  userAgent  String
  createdAt  DateTime @default(now())

  @@index([actorId, createdAt])
  @@index([targetType, targetId])
  @@map("audit_logs")
}

// ============================================================================
// TOKENS (Shared Trip + Invite)
// ============================================================================

model SharedTripToken {
  id          String    @id @default(uuid())
  tripId      String
  trip        Trip      @relation(fields: [tripId], references: [id], onDelete: Cascade)
  token       String    @unique
  createdBy   String
  expiresAt   DateTime
  revokedAt   DateTime?
  viewCount   Int       @default(0)
  importCount Int       @default(0)
  createdAt   DateTime  @default(now())

  @@index([token])
  @@map("shared_trip_tokens")
}

model InviteToken {
  id        String    @id @default(uuid())
  tripId    String
  trip      Trip      @relation(fields: [tripId], references: [id], onDelete: Cascade)
  token     String    @unique
  createdBy String
  maxUses   Int       @default(1)
  usedCount Int       @default(0)
  role      TripRole  @default(member)
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@map("invite_tokens")
}

// ============================================================================
// BACKFILL (Diary + Enrichment)
// ============================================================================

model BackfillTrip {
  id              String         @id @default(uuid())
  userId          String
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate       DateTime?
  endDate         DateTime?
  confidenceTier  ConfidenceTier
  source          String         @default("freeform")
  rawSubmission   String
  contextTag      TripContext?
  tripNote        String?
  status          BackfillStatus @default(processing)
  rejectionReason String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  legs    BackfillLeg[]
  venues  BackfillVenue[]
  signals BackfillSignal[]

  @@index([userId, status])
  @@map("backfill_trips")
}

model BackfillLeg {
  id             String       @id @default(uuid())
  backfillTripId String
  backfillTrip   BackfillTrip @relation(fields: [backfillTripId], references: [id], onDelete: Cascade)

  position Int
  city     String
  country  String
  timezone String?

  createdAt DateTime @default(now())

  venues BackfillVenue[]

  @@unique([backfillTripId, position])
  @@index([backfillTripId])
  @@map("backfill_legs")
}

model BackfillVenue {
  id                 String        @id @default(uuid())
  backfillTripId     String
  backfillTrip       BackfillTrip  @relation(fields: [backfillTripId], references: [id], onDelete: Cascade)
  backfillLegId      String?
  backfillLeg        BackfillLeg?  @relation(fields: [backfillLegId], references: [id])
  activityNodeId     String?
  activityNode       ActivityNode? @relation(fields: [activityNodeId], references: [id])
  extractedName      String
  extractedCategory  String?
  extractedDate      String?
  extractedSentiment String?
  latitude           Float?
  longitude          Float?
  resolutionScore    Float?
  isResolved         Boolean       @default(false)
  isQuarantined      Boolean       @default(false)
  quarantineReason   String?
  wouldReturn        Boolean?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  photos BackfillPhoto[]

  @@index([backfillTripId])
  @@index([activityNodeId])
  @@map("backfill_venues")
}

model BackfillPhoto {
  id               String        @id @default(uuid())
  backfillVenueId  String
  backfillVenue    BackfillVenue @relation(fields: [backfillVenueId], references: [id], onDelete: Cascade)
  gcsPath          String
  originalFilename String
  mimeType         String
  exifLat          Float?
  exifLng          Float?
  exifTimestamp    DateTime?
  createdAt        DateTime      @default(now())

  @@index([backfillVenueId])
  @@map("backfill_photos")
}

model TripPhoto {
  id               String        @id @default(uuid())
  trip             Trip          @relation(fields: [tripId], references: [id], onDelete: Cascade)
  tripId           String
  slot             ItinerarySlot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  slotId           String
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  gcsPath          String // GCS object path
  originalFilename String
  mimeType         String // image/jpeg, image/png, image/webp
  sizeBytes        Int?
  exifLat          Float?
  exifLng          Float?
  exifTimestamp    DateTime?
  createdAt        DateTime      @default(now())

  @@index([tripId])
  @@index([slotId])
  @@index([userId])
  @@map("trip_photos")
}

model BackfillSignal {
  id              String         @id @default(uuid())
  userId          String
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  backfillTripId  String
  backfillTrip    BackfillTrip   @relation(fields: [backfillTripId], references: [id], onDelete: Cascade)
  backfillVenueId String?
  signalType      String
  signalValue     Float
  confidenceTier  ConfidenceTier
  weight          Float
  earnedOut       Boolean        @default(false)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  personaDeltas PersonaDelta[]

  @@index([userId, createdAt])
  @@index([backfillTripId])
  @@map("backfill_signals")
}

model PersonaDelta {
  id                   String         @id @default(uuid())
  userId               String
  user                 User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  backfillSignalId     String
  backfillSignal       BackfillSignal @relation(fields: [backfillSignalId], references: [id], onDelete: Cascade)
  dimensionName        String
  personaScore         Float
  backfillImpliedScore Float
  delta                Float
  createdAt            DateTime       @default(now())

  @@index([userId, dimensionName])
  @@index([backfillSignalId])
  @@map("persona_deltas")
}

// ============================================================================
// USER SETTINGS (Preferences + Notifications + Consent)
// ============================================================================

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  dietary            String[] // validated via Zod: vegan, vegetarian, halal, kosher, gluten-free, nut-allergy, shellfish
  mobility           String[] // validated via Zod: wheelchair, low-step, elevator-required, sensory-friendly
  languages          String[] // validated via Zod: non-english-menus, limited-english-staff
  travelFrequency    String? // validated via Zod: few-times-year | monthly | constantly
  vibePreferences    String[] @default([])
  travelStyleNote    String?
  budgetComfort      String?
  spendingPriorities String[] @default([])
  accommodationTypes String[] @default([])
  transitModes       String[] @default([])
  preferencesNote    String?
  distanceUnit       String   @default("mi")
  temperatureUnit    String   @default("F")
  dateFormat         String   @default("MM/DD/YYYY")
  timeFormat         String   @default("12h")
  theme              String   @default("system")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("user_preferences")
}

model NotificationPreference {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tripReminders     Boolean  @default(true)
  morningBriefing   Boolean  @default(true)
  groupActivity     Boolean  @default(true)
  postTripPrompt    Boolean  @default(true)
  citySeeded        Boolean  @default(true)
  inspirationNudges Boolean  @default(false)
  productUpdates    Boolean  @default(false)
  checkinReminder   Boolean  @default(false)
  preTripDaysBefore Int      @default(3)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@map("notification_preferences")
}

model DataConsent {
  id                 String   @id @default(uuid())
  userId             String   @unique
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  modelTraining      Boolean  @default(false)
  anonymizedResearch Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("data_consents")
}

// ============================================================================
// PHANTOM TABLES (previously managed by Python CREATE TABLE IF NOT EXISTS)
// ============================================================================

model ShadowResult {
  id                  String   @id @default(uuid())
  modelId             String
  modelVersion        String
  userId              String
  tripId              String
  shadowRankings      Json
  productionRankings  Json
  overlapAt5          Float
  ndcgAt10            Float
  latencyMs           Int
  createdAt           DateTime @default(now())

  @@map("shadow_results")
}

model EvalRun {
  id           String   @id @default(uuid())
  modelId      String
  modelVersion String
  hrAt5        Float
  mrr          Float
  ndcgAt10     Float
  totalQueries Int
  durationMs   Int
  passedGates  Boolean
  gateDetails  Json     @default("{}")
  createdAt    DateTime @default(now())

  @@map("eval_runs")
}

model TrainingExtractRun {
  id            String   @id @default(uuid())
  targetDate    DateTime @db.Date
  status        String
  rowsExtracted Int      @default(0)
  filePath      String?
  durationMs    Int      @default(0)
  errorMessage  String?
  createdAt     DateTime @default(now())

  @@map("training_extract_runs")
}

model PersonaUpdateRun {
  id                Int      @id @default(autoincrement())
  runDate           DateTime @db.Date
  status            String
  usersUpdated      Int      @default(0)
  dimensionsUpdated Int      @default(0)
  durationMs        Int      @default(0)
  createdAt         DateTime @default(now())

  @@map("persona_update_runs")
}

model PushToken {
  id          String    @id @default(uuid())
  userId      String
  deviceToken String
  deviceId    String
  platform    String
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([userId, deviceId])
  @@map("push_tokens")
}

model EmailPreference {
  id           String   @id @default(uuid())
  userId       String
  category     String
  unsubscribed Boolean  @default(false)
  updatedAt    DateTime @updatedAt

  @@unique([userId, category])
  @@map("email_preferences")
}

// ============================================================================
// ENUMS
// ============================================================================

enum SubscriptionTier {
  free
  beta
  pro
  lifetime
}

enum SystemRole {
  user
  admin
}

enum TripMode {
  solo
  group
}

enum TripStatus {
  draft
  planning
  active
  completed
  archived
}

enum TripRole {
  organizer
  member
}

enum MemberStatus {
  invited
  joined
  declined
}

enum SlotType {
  anchor
  flex
  meal
  rest
  transit
}

enum SlotStatus {
  proposed
  voted
  confirmed
  active
  completed
  skipped
}

enum ActivityCategory {
  dining
  drinks
  culture
  outdoors
  active
  entertainment
  shopping
  experience
  nightlife
  group_activity
  wellness
}

enum NodeStatus {
  pending
  approved
  flagged
  archived
}

enum ResearchJobStatus {
  QUEUED
  ASSEMBLING_BUNDLE
  RUNNING_PASS_A
  RUNNING_PASS_B
  VALIDATING
  RESOLVING
  CROSS_REFERENCING
  WRITING_BACK
  COMPLETE
  VALIDATION_FAILED
  ERROR
}

enum ResearchTrigger {
  admin_seed
  tier2_graduation
  on_demand_fallback
}

enum KnowledgeSource {
  bundle_primary
  training_prior
  both
  neither
}

enum SignalType {
  // Slot interactions
  slot_view
  slot_tap
  slot_confirm
  slot_skip
  slot_swap
  slot_complete
  slot_dwell
  // Discovery
  discover_swipe_right
  discover_swipe_left
  discover_shortlist
  discover_remove
  // Vibe
  vibe_select
  vibe_deselect
  vibe_implicit
  // Post-trip
  post_loved
  post_skipped
  post_missed
  post_disliked
  // Pivot
  pivot_accepted
  pivot_rejected
  pivot_initiated
  // Trip-level
  trip_vibe_rating
  // Passive
  dwell_time
  scroll_depth
  return_visit
  share_action
  // Promoted implicit (Month 5+)
  considered_not_chosen
  soft_positive
  category_preference
  time_preference
  geographic_preference
  pace_signal
  // Feature units (2026-02-22)
  vote_cast
  invite_accepted
  invite_declined
  trip_shared
  trip_imported
  packing_checked
  packing_unchecked
  mood_reported
  slot_moved
  // V2 ML: disambiguation + preference (Phase 2.3)
  post_disambiguation
  negative_preference
  // V2 ML: subflow signals (Phase 5.1)
  rejection_recovery_trigger
  // Pre-launch behavioral scaffolding
  pre_trip_slot_swap
  pre_trip_slot_removed
  pre_trip_slot_added
  pre_trip_reorder
  // Pre-launch: explicit interaction signals (Wave 2)
  slot_confirmed
  slot_rejected
  card_viewed
  card_dismissed
  card_impression
  // Cold-start negative space (L4, L6)
  preset_selected
  preset_hovered
  preset_all_skipped
  pre_trip_slot_removed_reason
}

enum TripPhase {
  pre_trip
  active
  post_trip
}

enum IntentClass {
  explicit
  implicit
  contextual
}

enum ModelStage {
  staging
  ab_test
  production
  archived
}

enum PivotTrigger {
  weather_change
  venue_closed
  time_overrun
  user_mood
  user_request
}

enum PivotStatus {
  proposed
  accepted
  rejected
  expired
}

enum ConfidenceTier {
  tier_2
  tier_3
  tier_4
}

enum BackfillStatus {
  processing
  extracting
  resolving
  checking
  complete
  rejected
  quarantined
  archived
}

enum TripContext {
  solo
  partner
  family
  friends
  work
}

// V2 ML enums

enum SlotCompletionSignal {
  confirmed_attended
  likely_attended
  confirmed_skipped
  pivot_replaced
  no_show_ambiguous
}

enum ImportJobStatus {
  pending
  processing
  complete
  failed
}

enum CorpusIngestionStatus {
  pending
  matched
  unmatched
  rejected
}
